<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="ie=edge"/>
    <title>intentïon</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #B2B9BC; /* Blue sky hints */
            overflow: hidden;
            font-family: sans-serif;
            width: 100vw;
            height: 100vh;
            position: relative;
            z-index: 0;
        }
        .fogOne, .fogTwo, .fogThree, .fogFour, .fogFive {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-size: cover;
            animation: fadeInOut 10s infinite;
            pointer-events: none; /* Allow mouse events to pass through to elements below */
            z-index: 5; /* Lower than intention but above body */
        }
        .fogOne { background: url('vecteezy_white-fog-illustration_24065516-bottom-low.png') no-repeat center center; animation-duration: 3s; }
        .fogTwo { background: url('vecteezy_white-fog-illustration_24065530-bottom-risen.png') no-repeat center center; animation-duration: 4s; }
        .fogThree { background: url('vecteezy_white-fog-illustration_24065547-centre.png') no-repeat center center; animation-duration: 5s; }
        .fogFour { background: url('vecteezy_white-fog-illustration_24065523-corner-bottom-right.png') no-repeat center center; animation-duration: 6s; }
        .fogFive { background: url('vecteezy_white-fog-illustration_24065528-diagonal-down-right.png') no-repeat center center; animation-duration: 7s; }

        @keyframes fadeInOut {
            0%,100% { opacity: 0; }
            50%     { opacity: 1; }
        }

        #menu {
            position: absolute;
            left: 2%;
            top: 1%;
            opacity: 0;
            transition: opacity 3s;
            cursor: pointer;
            z-index: 100;
            width: 15vw; /* 25% of viewport width */
            height: 15vw; /* Make it a square */
            /*border: 2px solid transparent;*/
            border-radius: 5px;
            padding: 5px;
        }

        /*#menu:hover {
            border-color: #3F5965;
        }*/

        #menu img {
            position: absolute;
            top: -35%;
            left: -20%;
            width: calc(25vw - 10px); /* Account for padding */
            height: calc(25vw - 10px); /* Match container height minus padding */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            object-fit: contain; /* Ensure the image maintains its aspect ratio */
        }

        #menu-items {
            position: absolute;
            left: 5%;
            top: calc(5px + 15vw + 10px); /* Position below the menu (menu top position + menu height + padding) */
            background-color: rgba(255, 255, 255, 0.5);
            border: 2px solid #3F5965;
            border-radius: 5px;
            padding: 10px;
            display: none;
            z-index: 2000;
        }

        #menu-items a {
            display: block;
            color: #333;
            text-decoration: none;
            margin: 10px 0;
            padding: 5px;
            z-index: 2001;
            border: 1px solid transparent;
            transition: border-color 0.3s;
        }

        /* Default browser styling for experiment link */
        /*#experiment-link {
            color: blue;
            text-decoration: underline;
        }*/

        /* Allow default browser behavior for visited links */
        /*#experiment-link:visited {
            color: purple;
        }*/

        #menu-items a:hover {
            border-color: #3F5965;
        }

        #about-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid #3F5965;
            border-radius: 5px;
            padding: 20px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            z-index: 3000;
            display: none;
        }

        #what {
            color: #333;
            position: absolute;
            top: 2%;
            transform: translateY(-50%);
            font-size: 5vw;
            opacity: 0;
            transition: opacity 3s;
            pointer-events: none;
        }

        #intention {
            color: #333;
            position: absolute;
            top: 2%;
            transform: translateY(-50%);
            font-size: 5vw;
            opacity: 0;
            transition: opacity 3s;
            pointer-events: none;
            z-index: 10;
        }

        #running {
            color: #333;
            position: absolute;
            bottom: 5%;
            /*transform: translateY(-50%);*/
            font-size: 2.2vw;
            opacity: 0.5;
            /*transition: opacity 3s;*/
            pointer-events: none;
            z-index: 10;
        }

        #random-line {
            color: #333;
            position: absolute;
            font-size: 4vw;
            opacity: 0;
            transition: opacity 3s;
            pointer-events: none;
            z-index: 500; /* Behind giscus-container (z-index: 1000) */
            text-align: center;
            width: 80%;
            left: 10%;
        }

        /* VT100 Terminal Emulator Styles */
        #terminal-container {
            position: absolute;
            top: 5%;
            right: 5%;
            width: 75vw; /* 2/3 of viewport width */
            height: calc(66.67vw * 9 / 16); /* 16:9 aspect ratio */
            background-color: #000;
            opacity: 0.4;
            border: 2px solid #00FF00;
            border-radius: 5px;
            padding: 10px;
            box-sizing: border-box;
            font-family: "Courier New", monospace;
            overflow-y: auto; /* Changed from hidden to auto to enable vertical scrolling */
            z-index: 600;
        }

        #terminal-output {
            color: #00FF00; /* Classic green screen color */
            font-size: 1vw;
            line-height: 1.5;
            white-space: pre-wrap;
            /* Removed overflow: hidden to allow content to expand within the scrollable container */
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .cursor {
            display: inline-block;
            width: 0.8em;
            height: 1em;
            background-color: #00FF00;
            animation: blink 1s infinite;
            vertical-align: middle;
        }

        #giscus-container {
            position: absolute;
            width: 100%;
            left: 50%;
            transform: translateX(-50%);
            top: 20%;
            z-index: 1000;
            opacity: 0.9;
            padding: 2% 2%;
            box-sizing: border-box;
            max-height: 66.66vh;
            overflow-y: auto;
            background-color: rgba(180, 220, 255, 0.5);
        }
        @media (orientation: landscape) {
            #giscus-container {
                width: 50%;
            }
        }
    </style>
</head>
<body>

<div id="menu">
    <img src="brand/mesh/intention-mesh-transparent-steel.png" alt="Intention Mesh Steel" id="menu-img-1">
    <img src="brand/mesh/intention-mesh-transparent-black.png" alt="Intention Mesh White" id="menu-img-2">
</div>

<div id="menu-items">
    <a href="#" id="experiment-link">Experiments</a>
    <a href="#" id="about-link">About intentïon</a>
</div>

<div id="about-box">
    <h2>intentïon</h2>
    <p>intentïon.com showcases experiments from <a href="https://github.com/xn-intenton-z2a/repository0" target="_blank">repository0</a>
    using the <a href="https://github.com/xn-intenton-z2a/agentic-lib" target="_blank">agentic-lib</a> workflows.</p>
    <p>This website's repository is licensed under the GNU General Public License (GPL).</p>
</div>

<div class="fogOne"></div>
<div class="fogTwo"></div>
<div class="fogThree"></div>
<div class="fogFour"></div>
<div class="fogFive"></div>

<div id="what">What is your</div><div id="intention">intentïon</div>

<div id="running">The running experiment <a href="" target="_blank">branch URL will be here.</a></div>

<!-- VT100 Terminal Emulator -->
<div id="terminal-container">
    <div id="terminal-output"></div>
    <span class="cursor"></span>
</div>

<div id="random-line"></div>

<!-- ─────────────── giscus embed ─────────────── -->
<div id="giscus-container">
    <script src="https://giscus.app/client.js"
            data-repo="xn-intenton-z2a/repository0"
            data-repo-id="R_kgDON6E8ZA"
            data-category="General"
            data-category-id="DIC_kwDON6E8ZM4CpwzM"
            data-mapping="specific"
            data-term="Talk to the repository"
            data-strict="0"
            data-reactions-enabled="0"
            data-emit-metadata="0"
            data-input-position="top"
            data-theme="noborder_light"
            data-lang="en"
            crossorigin="anonymous"
            async>
    </script>
</div>
<!-- ────────────────────────────────────────────── -->

<script>
    console.log('Script started executing');

    // Function to show intention with a random position
    let isMenuVisible = false;
    let menuTimeout;
    let isWhatVisible = false;
    let whatTimeout;
    let isIntentionVisible = false;
    let intentionTimeout;
    let currentImageIndex = 0;
    let imageInterval;
    let menuItemsVisible = false;
    let aboutBoxVisible = false;

    // Variables for random lines from intentïon.md
    let intentionLines = [];
    let isRandomLineVisible = false;
    let randomLineTimeout;
    let randomLineFadeDuration = 3000; // 3 seconds for fade in/out
    let randomLinePauseDuration = 5000; // 5 seconds between lines

    // Variables for terminal display
    let terminalTimeout;
    let currentLineIndex = 0;
    let currentCharIndex = 0;
    let isTyping = false;
    let typingSpeed = 5; // milliseconds per character
    let linePauseDuration = 2000; // 2 seconds pause at end of line
    let clearScreenDuration = 1000; // 1 second for clear screen animation

    // Function to cycle through menu images
    function cycleMenuImages() {
        const images = [
            document.getElementById('menu-img-1'),
            document.getElementById('menu-img-2'),
        ];

        // Hide all images
        images.forEach(img => img.style.opacity = '0');

        // Show current image
        currentImageIndex = (currentImageIndex + 1) % images.length;
        images[currentImageIndex].style.opacity = '1';

        // Set the next timeout based on which image is showing
        if (imageInterval) clearTimeout(imageInterval);

        // menu-img-1 (index 0) shows for 0.9s, menu-img-2 (index 1) shows for 0.1s
        const nextDelay = currentImageIndex === 0 ? 1500 : 50;
        imageInterval = setTimeout(cycleMenuImages, nextDelay);
    }

    function showMenu() {
        const menu = document.getElementById('menu');
        menu.style.opacity = '1';
        isMenuVisible = true;

        // Clear any existing timeout
        if (menuTimeout) clearTimeout(menuTimeout);
        if (imageInterval) clearTimeout(imageInterval);

        // Start cycling images
        cycleMenuImages();

        // Hide menu after 10 seconds
        menuTimeout = setTimeout(() => {
            menu.style.opacity = '0';
            isMenuVisible = false;
            if (imageInterval) clearTimeout(imageInterval);

            // Also hide menu items if they're visible
            if (menuItemsVisible) {
                toggleMenuItems();
            }
        }, 10000);
    }

    // Function to toggle menu items visibility
    function toggleMenuItems() {
        const menuItems = document.getElementById('menu-items');

        if (menuItemsVisible) {
            menuItems.style.display = 'none';
            menuItemsVisible = false;
        } else {
            menuItems.style.display = 'block';
            menuItemsVisible = true;

            // Update experiment link
            const experimentLink = document.getElementById('experiment-link');
            const runningDiv = document.getElementById('running');
            const linkElement = runningDiv.querySelector('a');

            if (linkElement) {
                experimentLink.href = linkElement.href;
                experimentLink.target = "_blank"; // Add target="_blank" to open in new tab like the stand-alone link
                experimentLink.textContent = 'Current Experiment: ' + linkElement.textContent.substring(0, 30) + '...';
            } else {
                experimentLink.textContent = 'No current experiment';
                experimentLink.href = '#';
            }
        }
    }

    // Function to show/hide about box
    function toggleAboutBox() {
        const aboutBox = document.getElementById('about-box');

        if (aboutBoxVisible) {
            aboutBox.style.display = 'none';
            aboutBoxVisible = false;
        } else {
            aboutBox.style.display = 'block';
            aboutBoxVisible = true;
        }
    }

    // Hide about box when clicking anywhere
    function hideAboutBox() {
        if (aboutBoxVisible) {
            document.getElementById('about-box').style.display = 'none';
            aboutBoxVisible = false;
        }
    }

    // Hide menu items when clicking anywhere
    function hideMenuItems() {
        if (menuItemsVisible) {
            document.getElementById('menu-items').style.display = 'none';
            menuItemsVisible = false;
        }
    }

    function showWhat() {
        // Don't trigger if the "what" div is already visible
        if (isWhatVisible) return;

        const what = document.getElementById('what');
        // Set a random left position between 25% and 75%
        const randomLeft = Math.floor(Math.random() * (75 - 25 + 1)) + 25;
        what.style.left = `${randomLeft}%`;
        what.style.opacity = '1';
        //what.textContent = "What is your";
        isWhatVisible = true;

        // Clear any existing timeout
        if (whatTimeout) clearTimeout(whatTimeout);

        // Hide what after 0.75 seconds
        whatTimeout = setTimeout(() => {
            what.style.opacity = '0';
            isWhatVisible = false;
        }, 750);
    }

    function showIntention() {
        console.log('showIntention called'); // Debug log

        // Don't trigger if the "intention" div is already visible
        if (isIntentionVisible) {
            console.log('intention already visible, returning'); // Debug log
            return;
        }

        // Set a flag immediately to prevent multiple triggers during delay
        isIntentionVisible = true;
        console.log('Setting isIntentionVisible to true'); // Debug log

        const intention = document.getElementById('intention');
        // Set a random left position between 25% and 75%
        const randomLeft = Math.floor(Math.random() * (75 - 25 + 1)) + 25;
        intention.style.left = `${randomLeft}%`;
        console.log(`Setting left position to ${randomLeft}%`); // Debug log

        // Clear any existing timeout
        if (intentionTimeout) clearTimeout(intentionTimeout);

        // Add a delay of 1 second before showing the intention
        intentionTimeout = setTimeout(() => {
            intention.style.opacity = '1';
            console.log('Setting opacity to 1'); // Debug log

            // Hide intention after 3 seconds
            intentionTimeout = setTimeout(() => {
                intention.style.opacity = '0';
                isIntentionVisible = false;
                console.log('Setting isIntentionVisible to false'); // Debug log
            }, 3000);
        }, 1500);
    }

    // Show intention on mousemove (works on every mousemove)
    //console.log('Adding event listeners');

    // Make sure DOM is fully loaded before adding event listeners
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM fully loaded');

        // Show menu on mousemove
        document.body.addEventListener('mousemove', function(e) {
            console.log('mousemove event triggered');
            showMenu();
        });

        // Menu click handler
        document.getElementById('menu').addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent document click from firing
            toggleMenuItems();
        });

        // About link click handler
        document.getElementById('about-link').addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent document click from firing
            toggleAboutBox();
        });

        // Document click handler to hide about box and menu items
        document.addEventListener('click', function(e) {
            hideAboutBox();
            hideMenuItems();
        });

        // Prevent clicks inside about box from closing it
        document.getElementById('about-box').addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent document click from firing
        });

        // Prevent clicks inside menu items from closing it
        document.getElementById('menu-items').addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent document click from firing
        });
    });

    // Add event listeners immediately as well (in case DOMContentLoaded already fired)
    document.body.addEventListener('mousemove', function(e) {
        console.log('mousemove event triggered on body (immediate)');
        showMenu();
    });

    // Initialize menu images on page load
    window.addEventListener('load', function() {
        // Show first image
        document.getElementById('menu-img-1').style.opacity = '1';
        currentImageIndex = 0;

        // Start cycling images when menu is visible
        if (isMenuVisible) {
            cycleMenuImages();
        }
    });

    // Call showIntention directly after a short delay to test if it works
    console.log('Setting timeout to call showIntention directly');
    setTimeout(function() {
        console.log('Calling showIntention directly');
        showMenu();
        showWhat();
        showIntention();
    }, 5000);

    // Function to show a random line from intentïon.md (no longer used, replaced by terminal display)
    function showRandomLine() {
        // Don't proceed if there are no lines or if a line is already visible
        if (intentionLines.length === 0 || isRandomLineVisible) return;

        // Set flag to prevent multiple triggers
        isRandomLineVisible = true;

        const randomLineDiv = document.getElementById('random-line');

        // Select a random line from intentionLines
        const randomIndex = Math.floor(Math.random() * intentionLines.length);
        const randomLine = intentionLines[randomIndex];

        // Set random vertical position between 20% and 80%
        const randomTop = Math.floor(Math.random() * (80 - 20 + 1)) + 20;
        randomLineDiv.style.top = `${randomTop}%`;

        // Clear any existing timeout
        if (randomLineTimeout) clearTimeout(randomLineTimeout);

        // Show the random line
        randomLineDiv.textContent = randomLine;
        randomLineDiv.style.opacity = '1';

        // Hide the random line after the fade duration
        randomLineTimeout = setTimeout(() => {
            randomLineDiv.style.opacity = '0';

            // Reset flag and schedule next line after pause duration
            randomLineTimeout = setTimeout(() => {
                isRandomLineVisible = false;
                showRandomLine(); // Show next random line
            }, randomLinePauseDuration);
        }, randomLineFadeDuration);
    }

    // Function to type a character at a time in the terminal
    function typeCharacter() {
        if (intentionLines.length === 0 || currentLineIndex >= intentionLines.length) {
            currentLineIndex = 0; // Reset to beginning if we've gone through all lines
            // Clear the screen only when we've gone through all lines
            const terminalOutput = document.getElementById('terminal-output');
            terminalOutput.textContent = '';
        }

        const terminalOutput = document.getElementById('terminal-output');
        const terminalContainer = document.getElementById('terminal-container');
        const currentLine = intentionLines[currentLineIndex];

        if (currentCharIndex < currentLine.length) {
            // Add next character
            terminalOutput.textContent += currentLine.charAt(currentCharIndex);
            currentCharIndex++;

            // Auto-scroll to the bottom to ensure the latest content is visible
            terminalContainer.scrollTop = terminalContainer.scrollHeight;

            // Schedule next character
            terminalTimeout = setTimeout(typeCharacter, typingSpeed);
        } else {
            // Finished typing the line, pause before starting next line
            isTyping = false;
            terminalTimeout = setTimeout(startNextLine, linePauseDuration);
        }
    }

    // Function to clear the screen with an animation
    function clearScreenWithAnimation() {
        const terminalOutput = document.getElementById('terminal-output');
        const content = terminalOutput.textContent;

        // If no content, just start next line
        if (!content) {
            startNextLine();
            return;
        }

        // Create animation effect by removing characters one by one
        let charCount = content.length;
        const clearInterval = 10; // milliseconds between character removal
        const totalClearTime = clearScreenDuration;
        const removeDelay = totalClearTime / charCount;

        function removeChar() {
            if (charCount > 0) {
                terminalOutput.textContent = content.substring(0, charCount - 1);
                charCount--;
                setTimeout(removeChar, removeDelay);
            } else {
                // Screen cleared, start next line
                startNextLine();
            }
        }

        removeChar();
    }

    // Function to start typing the next line
    function startNextLine() {
        if (isTyping) return;

        isTyping = true;
        currentCharIndex = 0;

        // Increment line index
        currentLineIndex = (currentLineIndex + 1) % intentionLines.length;

        // Add a newline character before starting the next line (except for the first line)
        if (currentLineIndex !== 0) {
            const terminalOutput = document.getElementById('terminal-output');
            const terminalContainer = document.getElementById('terminal-container');
            terminalOutput.textContent += '\n';

            // Auto-scroll to the bottom to ensure the latest content is visible
            terminalContainer.scrollTop = terminalContainer.scrollHeight;
        }

        // Start typing the next line
        typeCharacter();
    }

    // Function to start the terminal display
    function startTerminalDisplay() {
        // Don't start if there are no lines or already typing
        if (intentionLines.length === 0 || isTyping) return;

        // Clear any existing timeout
        if (terminalTimeout) clearTimeout(terminalTimeout);

        // Start typing the first line
        startNextLine();
    }

    // Function to poll the intention URL and update the running div
    function pollIntentionUrl() {
        const intentionUrl = 'https://raw.githubusercontent.com/xn-intenton-z2a/repository0/main/intentïon.md';
        const runningDiv = document.getElementById('running');

        // Fetch the intention file
        fetch(intentionUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.text();
            })
            .then(content => {
                // Split the content into lines
                const lines = content.split('\n');

                // Store all non-empty lines for random display
                intentionLines = lines.filter(line => line.trim() !== '');
                console.log(`Stored ${intentionLines.length} lines from intentïon.md`);

                // Start the terminal display if not already typing
                if (!isTyping) {
                    startTerminalDisplay();
                }

                // Filter to lines matching GitHub branch URLs using the same pattern as in agent-archive-intentïon.yml
                //const branchUrlPattern = /^\s*https:\/\/github\.com\/[^\/\s]+\/[^\/\s]+\/(tree|blob|edit|new|upload|commits)\/[^\s]+|https:\/\/github\.com\/[^\/\s]+\/[^\/\s]+\/compare\/[^.\/]+\.{3}[^\/\s]+/;
                const branchUrlPattern = /^.*https:\/\/.*\/tree\/.*$/
                const branchUrlLines = lines.filter(line => branchUrlPattern.test(line));

                if (branchUrlLines.length === 0) {
                    console.log('No matching GitHub branch URL found in intentïon.md');
                    runningDiv.textContent = 'No current experiment branch found.';
                } else {
                    // Get the last matching line
                    const lastUrlLine = branchUrlLines[branchUrlLines.length - 1];

                    // Extract URL by ignoring anything before the first https:// and up to the first non-url character
                    const urlMatch = lastUrlLine.match(/https:\/\/[^ ]+/);
                    if (urlMatch) {
                        const branchUrl = urlMatch[0];
                        console.log(`Found branch URL: ${branchUrl}`);

                        // Update the running div with a clickable link
                        runningDiv.innerHTML = `Activity log: <a href="${branchUrl}/intentïon.md" target="_blank" style="pointer-events: auto;">intentïon.md</a>`;
                    } else {
                        console.log(`No matching GitHub branch URL found in line: ${lastUrlLine}`);
                        runningDiv.textContent = 'No current experiment branch found.';
                    }
                }
            })
            .catch(error => {
                console.error('Error fetching intention file:', error);
                runningDiv.textContent = 'Error fetching current experiment branch.';
            });
    }

    // Poll the intention URL immediately and then every minute
    pollIntentionUrl();
    setInterval(pollIntentionUrl, 60000); // 60000 ms = 1 minute
</script>

</body>
</html>
